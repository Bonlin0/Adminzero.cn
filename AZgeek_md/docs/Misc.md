# 杂项

一些暂时不足以建立单独分类的内容。可能与所学课程有关。

### 理解傅里叶变换

最近通信原理课程让我想起一篇很久以前看到的教程，简单易懂。[https://zhuanlan.zhihu.com/p/19763358](https://zhuanlan.zhihu.com/p/19763358)

### C中复杂声明

一篇解读C语言中复杂声明的博客。其实一般情况下看上去比较让人一头雾水的声明基本都是函数指针的声明。[https://blog.csdn.net/hshl1214/article/details/5647591](https://blog.csdn.net/hshl1214/article/details/5647591)

### VirutalBox6.0 安装 CentOS7 鼠标不显示问题

[https://www.jianshu.com/p/16c03bfbef29](https://www.jianshu.com/p/16c03bfbef29) 这篇文章可以解决问题。但是明显感觉鼠标移动卡顿且呈跳跃性移动。但是总比没有鼠标要强。

---

## 通信与编码

### 循环冗余校验（CRC, Cyclical Redundancy Check)

举简单例子说明，不做通用概括的解释。

例我们以多项式$g(x)=x^4+x^3+x^2+1$作为生成多项式，即二进制表示11101.

设我们要传递的消息 m = 110.

有CRC冗余码计算过程如下

1. 将m左移$g(x)$的最高次项位得到$m_0$。（其实就是生成多项式的二进制表示有x位就左移x-1位）
2. 将$m_0$除以生成多项式（$GF(2)$下除法）
3. 得到余数后与$m_0$相加（其实就是把$m_0$后面的x-1个0替换成了余数）
4. 上一步得到的结果即完整的CRC码，包括了信息位与校验位。直接发送给接收方
5. 接受方收到后拿完整的CRC码除以生成多项式，正常情况下为0，不为0表示数据一定发生了变化（数据位或校验位）


---

## Java

泛型不可以是原始类型（ int, char, double... ），需要在泛型中使用原始类型需要使用其包装类型。

|基本类型|包装类|
|-|-|
|boolean|Boolean|
|byte|Byte|
|short|Short|
|int|Integer|
|long|Long|
|float|Float|
|double|Double|
|char|Character|

Java Random类的nextInt(x)是前闭后开，即可能会返回0，但最大为x-1 。

---

## Windows

### 查看本机端口占用

`netstat -ano`

---

## PHP

### at symbol

at符号（@）在PHP中用作错误控制操作符。当表达式附加@符号时，将忽略该表达式可能生成的错误消息。如果启用了track_errors功能，则表达式生成的错误消息将保存在变量$ php_errormsg中。每个错误都会覆盖此变量。

---

## 汇编语言

### $ and $$

NASM 编译的汇编语言中，`$`是当前行的地址，`$$`是当前段的段首地址。

### 汇编 CLD 与 STD

二者均是用来操作方向标志位DF（Direction Flag）。cld使DF 复位，即是让DF=0，std使DF置位，即DF=1.这两个指令用于串操作指令中。通过执行cld或std指令可以控制方向标志DF，决定内存地址是增大（DF=0，向高地址增加）还是减小（DF=1，向地地址减小）。

PS ： LODSB and LODSW

这是块装入指令,把SI指向的存储单元读入累加器,LODSB就读入AL,LODSW就读入AX中,然后SI自动增加或减小1或2.

---

$$x=y^2$$

## Some notes

### PHP

PHP int overflow: 如果给定的一个数超出了 integer 的范围，将会被解释为 float。同样如果执行的运算结果超出了 integer 范围，也会返回 float。  
PHP float to int:向下取整。

PHP 7.0.0 起，NaN 和 Infinity 在转换成 integer 时，不再是 undefined 或者依赖于平台，而是都会变成零。  

发现url中有?file=字样时可以修改后面为?file=php://filter/convert.base64-encode/resource=xxx.php来查看对应文件源码。  



### Javascript

Javascript中NaN这个特殊的Number与所有其他值都不相等，包括它自己。

### Probability and Mathematical Statistic

<img src="../img/useful_power_series.png" alt="useful_power_series">

### Chinese Copywriting Guidelines 中文排版指北

[Chinese Copywriting Guidelines 中文排版指北](https://github.com/mzlogin/chinese-copywriting-guidelines) ， 一个关于中文文档内容书写的规范，努力达成！

### Docker 官网镜像

[https://hub.docker.com/search/?type=image&image_filter=official](https://hub.docker.com/search/?type=image&image_filter=official)

### Web Extension

Mozilla Web 扩展教程： [你的第一个 Web Extension](https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions/Your_first_WebExtension)

---

## 机器学习

由于信息隐藏课程结课项目需要入门机器学习。

### SoftMax Algorithm

又称`归一化指数函数`， 大致思路是从多个输入中输出一个，而大概率（并非绝对）输出最大的输入。即其他输入也有小概率被输出。

具体运算规则是，将每个输入作为以e为底的指数函数的指数，将每个计算出来的结果求和，再对每一个结果除以该总和，及该输入的输出概率。

即对于多个输入$x_1$, $x_2$, $\cdots$, $x_n$. 有$x_i$被输出的概率为 

$$ P_i = \frac{e^x_i}{\sum_{j=1}^{n}e^x_j}$$

---

## Latex 语法

### 分数表示

分数通过`\frac{ }{ }`来表示，在两个括号内输入对应的表达式即可，分式会被自动缩小，如果过小需要使用上述调整大小方式调整。

如 `$$ P_i = \frac{e^x_i}{\sum_{j=1}^{n}e^x_j}$$` 会被输出为：

$$ P_i = \frac{e^x_i}{\sum_{j=1}^{n}e^x_j}$$

### 约等号和不等号的表示

约等号使用 `\approx`，小于等于使用`\le`或`\leq`，大于等于使用`\ge`或`\geq`，大于或小于则不需转义。

`$a\approx b$` : $a\approx b$

### 省略号的表示

使用`\cdots`即可表示出位于中间的三个连续点。 额外补充几种点的表示。

* $\cdots$  `\cdots`
* $\ddots$  `\ddots`
* $\ldots$  `\ldots`
* $\vdots$  `\vdots` 

### 对于需要调整大小的情形

使用  `\tiny\scriptsize\small\normalsize\large\Large\LARGE\huge\Huge` 进行调整.

$$\tiny A \scriptsize A \small A\normalsize A\large A\Large A\LARGE A\huge A\Huge A$$

```
\tiny A \scriptsize A \small A\normalsize A\large A\Large A\LARGE A\huge A\Huge A
```

---

## Git

### git ignore 不奏效

一般情况下出现这种问题有以下两个原因。

1.  `gitignore`语法错误。
2.  要 ignore 的文件已经被 add, commit, push。

对于第一种，请查看[gitignore的语法规则](https://git-scm.com/docs/gitignore)。

对于第二种，可以使用 git rm --cache 文件名 的命令删除该文件在 git 中的记录，示例代码如下。

```bash
git rm --cache a.java
```


---

## 区块链？

我尝试去用尽可能好理解的文字让大家能够对区块链有一个非常基本的概念。

### 预备知识

计算机世界是以二进制数为基础的。也就是说你看到这段文字实际上也是0和1的某种组合传到你的电脑或手机上的。

比特 bit：一个二进制位，只有可能是0或者1.一般用小写b表示。

字节 bytes：8个二进制位或者说8个比特。一般用大写B表示。

密码学有一种东西叫做哈希函数 然后哈希函数能够针对任何数字信息生成一定长度的 哈希（hash） 这个东西也是一个二进制数字串 然后hash的特性就是你输入的信息发生一点变化 再次生成的hash就会变得很不一样 所以我们可以为一些不能变动的东西计算哈希，并且单独保存，如果有一天坏人修改了你的不能变动的东西，你再次计算哈希，就会发现结果与之前不一样，就说明有人动了这个东西，你要警觉了，一般的做法就会把这个被动过的东西扔掉了报警.

要体验哈希函数可以直接百度“在线哈希”，就可以感性的感受一下什么是哈希了。而且哈希函数的设计要求之一是 你很难通过一个哈希值 逆推出一个正确的输入。就是拿着result理论上是有很多种输入能够算出这个result的 但是这个过程是计算困难的 这个就是哈希函数设计安全性的问题了。你也可以看到输出基本上都是乱码 随机数。具体哈希的设计和实现是很复杂的 但是理解他的设计思路还是很简单的。

### 正文

区块链就是广泛使用哈希函数。区块其实就是一个结构，里面包括了一些东西，最典型的就是一些交易信息，张三给李四付了1个比特币这样，然后我们会给这个区块计算哈希，这样以后如果有人篡改区块，我们检查哈希就知道了这个区块是不是正确的，而区块链呢，就是我们每一个区块都要存储上一个区块的哈希信息，所以区块就是串成一串的形式。并且你没法篡改之前的交易信息，因为已经被哈希绑死了。

而现在广泛应用的区块链去中心化什么的，就是说我们每个人每个参与区块链的人都要拷贝一份从始至今的区块链，然后并且互相沟通确保区块链保持最新，这就是所谓的Pto(2)P。而相对的，目前还在大规模使用的架构CS架构，是指一个中心服务器存储所有信息，而用户向服务器请求服务这个样子,如果服务器改了一些东西，所有的用户都没有办法。

然后呢区块链有个要求 就是区块里面有一个部分本身是没有任何信息的（叫nonce） 你要从区块链上加一个区块也没呢么容易 你需要让你的区块的哈希满足一个条件 比如前n位是00000这样子 而哈希本身的输出几乎是随机数 所以你要在区块的信息构建好之后 给他这个没有任何信息的部分取随机数 测试整合起来的区块的哈希是不是满足条件 如果足够幸运就能试出来一个满足条件的nonce 能够使整个区块的哈希满足一个特定条件 测试这个nocne的过程就叫挖矿。

然后测试到一个正确nonce 生成区块以后 你就要向区块链世界的其他人发广播告诉别人这个新的区块的相关信息 别人就知道了 哦区块链上多了一块。然后由于计算一个合法区块是很难的 所以挖矿比较困难 具体区块链运营还有很多细节的东西 保证区块链能够正常运行。

然后具体运行大概就是 交易信息 张三给李四100块钱 李四给王五20块钱 这样的信息被写入区块 然后矿工为这个区块计算哈希 并且测试满足条件的nonce 是的哈希达到要求 然后找到以后把这个新区块广播给别人 这笔交易就算是被全世界公认了 并且没有人能够反悔 或者篡改 因为这个信息已经被写入到全世界的账本里了。而矿工也会得到相应的挖矿奖励 就是计算nonce的奖励。同时还有一些共识算法 就是如果你恶意伪造交易信息 区块链世界也有办法应对。

---

## 零基础介绍计算机领域基本常识

### 开放源代码

开放源码就可以看作一个生产某种专业器件的工厂 ，然后一般来说这个工厂是禁止外人出入的，只有自己人才知道工厂内部的东西，比如工厂内部生产期间的流水线，各种流程怎么处理原材料，怎么生产。在外人看来就是这个工厂买了铁啊什么的原材料，做出来了精美的器件，外人想自己办个工厂做出来一样的器件或者想对这个器件的某个参数进行调整，就很困难几乎不可能，开放源代码就是工厂把自己厂房都公开给全世界看，然后全世界都知道这个器件怎么生产出来的了，然后随便谁都可以用类似的流水线造一个工厂生产出一模一样的器件，同时还可以对某个部分工艺流程进行细微调整，这样子可以生产出最满足某人个人需求的器件，而不用彻底白手起家。于此同时，你开放了自己工厂的所有流程，全世界都会评价你的厂房是否设计合理，流程是否有不合理低效的部分，所以你就能对自己的工厂进行进一步的提升。

在前面的类比中，工厂其实就是软件，而内部的流水线和管理和生产工艺等就是软件的源代码，有了源代码，你可以构建出无数套软件，甚至可以对源代码进行细微的修改以构建出最合适你的软件。

第一段叙述中最后一条所叙述的内容也是开源代码被认为更安全的原因，因为全世界使用你的代码的人们都会审视你的源代码（工厂的组织、流水线、制度）。如果有任何不合理的部分，会产生安全漏洞的部分，会很“容易”（当然有时候也不太容易）被人发现并及时公开修复。

---

### Oracle NUMBER类型

类型：NUMBER （ precision， scale）

* precision表示数字中的有效位;如果没有指定precision的话，Oracle将使用38作为精度。如果scale大于零，表示数字精确到小数点右边的位数；scale默认设置为0；如果scale小于零，Oracle将把该数字取舍到小数点左边的指定位数。
* Precision的取值范围为【1---38】；Scale的取值范围为【-84---127】。

例如NUMBER(38,3)中总位数是38，小数点后精确到3位，

参考网址 [https://www.cnblogs.com/oumyye/p/4448656.html](https://www.cnblogs.com/oumyye/p/4448656.html)

